name: "Code Sign Action"
description: "A GitHub Action for code signing files. Particularly those generated with vercel/pkg."
branding:
  color: purple
  icon: lock
inputs:
  # Required
  file:
    description: "The file to sign"
    required: true
  certificate-data:
    description: "A `base64` encoded string of your `p12` or `pfx` cert contents. Note: if you use KeyLocker, this will be the base64 encoded client certificate (`SM_CLIENT_CERT_FILE`)"
    required: true
  certificate-password:
    description: "The password to unlock the certificate-data"
    required: true

  # Optional
  apple-notary-password:
    description: "The Apple Developer account password to use in notarization"
    required: false
  apple-notary-user:
    description: "The Apple Developer account email to use in notarization"
    required: false
  apple-notary-tool:
    description: "The xcrun tool to use to notarize."
    required: false
    default: notarytool
  apple-product-id:
    description: "The unique product ID to use for notarization"
    required: false
  apple-team-id:
    description: "The Apple Developer account Team ID"
    required: false
  certificate-id:
    description: "A string to identify the correct signing cert"
    required: true
  keylocker-api-key:
    description: "The API key to use for KeyLocker"
    required: false
  keylocker-cert-sha1-hash:
    description: "The SHA1 hash of the certificate to use for KeyLocker"
    required: false
  keylocker-host:
    description: "The host to use for KeyLocker"
    required: false
  keylocker-keypair-alias:
    description: "The alias of the keypair to use for KeyLocker"
    required: false
  options:
    description: "Extra options to pass to the codesigning tool"
    required: false
  signtool:
    description: "The signtool to use"
    required: false
    default: auto

outputs:
  file:
    description: "The path to the signed binary."
    value: ${{ steps.code-sign-action.outputs.file }}

runs:
  using: composite
  steps:
    - name: Validate user inputs
      shell: bash
      run: |
        echo "::group::Ensure file is set"
        if [ "${{ inputs.file }}" == "" ]; then
          echo "::error title=File is not set!::You must specify a file to sign!"
          exit 1
        fi
        echo "::endgroup::"

        echo "::group::Ensure cert data is set"
        if [ "${{ inputs.certificate-data }}" == "" ]; then
          echo "::error title=Cert data is not set!::You must specify the cert you want to sign with!"
          exit 2
        fi
        echo "::endgroup::"

        echo "::group::Ensure certificate password is set"
        if [ "${{ inputs.certificate-password }}" == "" ]; then
          echo "::error title=Cert password is not set!::You must specify the password to unlock the cert with!"
          exit 2
        fi
        echo "::endgroup::"

    - name: Set generic internal inputs
      shell: bash
      id: code-sign-action-generic-internal
      run: |
        # standardize os stuff
        if [ "${{ runner.os }}" == "Linux" ]; then
          echo "os=linux" >> $GITHUB_OUTPUT
        elif [ "${{ runner.os }}" == "macOS" ]; then
          echo "os=macos" >> $GITHUB_OUTPUT
        elif [ "${{ runner.os }}" == "Windows" ]; then
          echo "os=win" >> $GITHUB_OUTPUT
        fi

        # cert id
        if [ "${{ runner.os }}" == "macOS" ] && [[ -n "${{ inputs.apple-team-id }}" ]]; then
          echo "signid=${{ inputs.apple-team-id }}" >> $GITHUB_OUTPUT
        else
          echo "signid=${{ inputs.certificate-id }}" >> $GITHUB_OUTPUT
        fi

        # signtool discovery if needed
        if [ "${{ inputs.signtool }}" == "auto" ]; then
          # keylocker
          if [ "${{ runner.os }}" != "macOS" ] \
            && [[ -n "${{ inputs.keylocker-api-key }}" ]] \
            && [[ -n "${{ inputs.keylocker-cert-sha1-hash }}" ]] \
            && [[ -n "${{ inputs.host }}" ]] \
            && [[ -n "${{ inputs.keylocker-keypair-alias }}" ]]; then
            echo "signtool=keylocker" >> $GITHUB_OUTPUT

          # signtool
          elif [ "${{ runner.os }}" == "Windows" ]; then
            echo "signtool=signtool" >> $GITHUB_OUTPUT

          # osslsigncode
          elif [ "${{ runner.os }}" == "Linux" ]; then
            echo "signtool=osslsigncode" >> $GITHUB_OUTPUT

          # codesign
          elif [ "${{ runner.os }}" == "macOS" ]; then
            echo "signtool=codesign" >> $GITHUB_OUTPUT
          fi
        fi

        # notarize logix
        if [ "${{ runner.os }}" == "macOS" ] \
          && [[ -n "${{ inputs.apple-notary-password }}" ]] \
          && [[ -n "${{ inputs.apple-notary-user }}" ]] \
          && [[ -n "${{ inputs.apple-product-id }}" ]]; then
          echo "notarize=true" >> $GITHUB_OUTPUT
        fi

    - name: Set osy internal inputs
      shell: powershell
      if: runner.os == 'Windows'
      id: code-sign-action-win-internal
      run: |
        # sign cert
        $certpath = "$env:RUNNER_TEMP\signcert.p12"
        Write-Output "signcert=$certpath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

        # input file
        if ((Split-Path -Path "${{ inputs.file }}" -IsAbsolute) -eq $true) {
          Write-Output "file=${{ inputs.file }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        } else {
          Write-Output "file=$(Get-Location)/${{ inputs.file }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        }

    - name: Set osy internal inputs
      shell: bash
      if: runner.os != 'Windows'
      id: code-sign-action-posix-internal
      run: |
        # sign cert
        certpath="$RUNNER_TEMP/signcert.p12"
        echo "signcert=$certpath" >> $GITHUB_OUTPUT

        # input file
        if [[ "${{ inputs.file }}" == /* ]]; then
          echo "file=${{ inputs.file }}" >> $GITHUB_OUTPUT
        else
          echo "file=$(pwd)/${{ inputs.file }}" >> $GITHUB_OUTPUT
        fi

    - name: Set internal inputs
      shell: bash
      id: code-sign-action-internal
      run: |
        # generics
        echo "notarize=${{ steps.code-sign-action-generic-internal.outputs.notarize }}" >> $GITHUB_OUTPUT
        echo "os=${{ steps.code-sign-action-generic-internal.outputs.os }}" >> $GITHUB_OUTPUT
        echo "signid=${{ steps.code-sign-action-generic-internal.outputs.signid }}" >> $GITHUB_OUTPUT
        echo "signtool=${{ steps.code-sign-action-generic-internal.outputs.signtool }}" >> $GITHUB_OUTPUT

        # osy
        if [ "${{ runner.os }}" == "Windows" ]; then
          echo "file=${{ steps.code-sign-action-win-internal.outputs.file }}" >> $GITHUB_OUTPUT
          echo "signcert=${{ steps.code-sign-action-win-internal.outputs.signcert }}" >> $GITHUB_OUTPUT
        else
          echo "file=${{ steps.code-sign-action-posix-internal.outputs.file }}" >> $GITHUB_OUTPUT
          echo "signcert=${{ steps.code-sign-action-posix-internal.outputs.signcert }}" >> $GITHUB_OUTPUT
        fi

    - name: Verify Outputs
      shell: bash
      run: |
        echo "::group::Internal output information"
        echo "file=${{ steps.code-sign-action-internal.outputs.file }}"
        echo "notarize=${{ steps.code-sign-action-internal.outputs.notarize }}"
        echo "os=${{ steps.code-sign-action-internal.outputs.os }}"
        echo "signcert=${{ steps.code-sign-action-internal.outputs.signcert }}"
        echo "signid=${{ steps.code-sign-action-internal.outputs.signid }}"
        echo "signtool=${{ steps.code-sign-action-internal.outputs.signtool }}"
        echo "::endgroup::"

    - name: Validate linux specific inputs
      shell: bash
      if: steps.code-sign-action-internal.outputs.os == 'linux'
      run: |
        # supported codesigner
        if [ "${{ steps.code-sign-action-internal.outputs.signtool }}" != "osslsigncode" ] \
          && [ "${{ steps.code-sign-action-internal.outputs.signtool }}" != "keylocker" ] \
          && [ "${{ steps.code-sign-action-internal.outputs.signtool }}" != "smctl" ]; then
          echo "::error::You must specify osslsigncode, keylocker or smctl as your signtool! You specified ${{ steps.code-sign-action-internal.outputs.signtool }}."
          exit 1
        fi
    - name: Validate macos specific inputs
      shell: bash
      if: steps.code-sign-action-internal.outputs.os == 'macos'
      run: |
        # supported codesigner
        if [ "${{ steps.code-sign-action-internal.outputs.signtool }}" != "codesign" ]; then
          echo "::error::You must specify osslsigncode, keylocker or smctl as your signtool! You specified ${{ steps.code-sign-action-internal.outputs.signtool }}."
          exit 1
        fi

        # team id
        if [ "${{ steps.code-sign-action-internal.outputs.signid }}" == "" ]; then
          echo "::error::You must specify a certificate-id or apple-team-id to sign!"
          exit 1
        fi
    - name: Validate windows specific inputs
      shell: bash
      if: steps.code-sign-action-internal.outputs.os == 'win'
      run: |
        # supported codesigner
        if [ "${{ steps.code-sign-action-internal.outputs.signtool }}" != "signtool" ] \
          && [ "${{ steps.code-sign-action-internal.outputs.signtool }}" != "keylocker" ] \
          && [ "${{ steps.code-sign-action-internal.outputs.signtool }}" != "smctl" ]; then
          echo "::error::You must specify osslsigncode, keylocker or smctl as your signtool! You specified ${{ steps.code-sign-action-internal.outputs.signtool }}."
          exit 1
        fi

    - name: Dump certs
      if: steps.code-sign-action-internal.outputs.os == 'linux'
      run: |
        echo "::group::Dumping inputs.certificate-data"
        echo "Dumping cert to ${{ steps.code-sign-action-internal.outputs.signcert }}..."
        echo "${{ inputs.certificate-data }}" | base64 --decode | sudo install -D /dev/stdin "${{ steps.code-sign-action-internal.outputs.signcert }}"
        echo "::endgroup::"
    - name: Dump certs
      if: steps.code-sign-action-internal.outputs.os == 'macos'
      run: |
        echo "::group::Dumping inputs.certificate-data"
        echo "Dumping cert to ${{ steps.code-sign-action-internal.outputs.signcert }}..."
        echo "${{ inputs.certificate-data }}" | base64 --decode > "${{ steps.code-sign-action-internal.outputs.signcert }}"
        echo "::endgroup::"
    - name: Dump certs
      shell: powershell
      if: steps.code-sign-action-internal.outputs.os == 'win'
      run: |
        echo "::group::Dumping inputs.certificate-data"
        Write-Output "Dumping cert to ${{ steps.code-sign-action-internal.outputs.signcert }}..."
        $bytes = [Convert]::FromBase64String("${{ inputs.certificate-data }}")
        [IO.File]::WriteAllBytes("${{ steps.code-sign-action-internal.outputs.signcert }}", $bytes)
        echo "::endgroup::"

    # @TODO: signing with osslsigncode on linux

    # signing with codesign on macos
    - name: Signing with ${{ steps.code-sign-action-internal.outputs.signtool }} (${{ steps.code-sign-action-internal.outputs.os }})
      if: steps.code-sign-action-internal.outputs.signtool == 'codesign'
      run: |
        echo "::group::Signsetup"
        # Throw error if file does not exist
        if [ ! -f "${{ steps.code-sign-action-internal.outputs.file }}" ]; then
          echo "${{ steps.code-sign-action-internal.outputs.file }} does not exist!"
          exit 5
        fi

        function import_cert() {
          security import "$1" -k ~/Library/Keychains/macos-build.keychain -P "$2" -T /usr/bin/codesign -T /usr/bin/productsign
        }

        # Create keychain
        security create-keychain -p actions macos-build.keychain
        security default-keychain -s macos-build.keychain
        security unlock-keychain -p actions macos-build.keychain
        security set-keychain-settings -t 3600 -u macos-build.keychain

        # attempt to import p12 directly but fallback if it fails
        if ! import_cert "${{ steps.code-sign-action-internal.outputs.signcert }}" "${{ inputs.certificate-password }}"; then
          openssl pkcs12 -in "${{ steps.code-sign-action-internal.outputs.signcert }}" -nocerts -out "$RUNNER_TEMP/codesign.key" -nodes -password pass:"${{ inputs.certificate-password }}"
          openssl pkcs12 -in "${{ steps.code-sign-action-internal.outputs.signcert }}" -clcerts -nokeys -out "$RUNNER_TEMP/codesign.crt" -password pass:"${{ inputs.certificate-password }}"
          import_cert "$RUNNER_TEMP/codesign.key" ""
          import_cert "$RUNNER_TEMP/codesign.crt" ""
        fi

        # Key signing
        security set-key-partition-list -S apple-tool:,apple: -s -k actions macos-build.keychain
        echo "::endgroup::"

        # Scope out the keychain
        security find-identity -v macos-build.keychain

        # Force the codesignature
        codesign --force ${{ inputs.options }} -s "${{ steps.code-sign-action-internal.outputs.signid }}" "${{ steps.code-sign-action-internal.outputs.file }}"

        # Verify the code signature
        codesign -v "${{ steps.code-sign-action-internal.outputs.file }}" --verbose


    # @TODO: signing with signtool on windows

    # @TODO: signing with keylocker on linux
    # @TODO: signing with keylocker on windows

    # @TODO: notarizing on macos

    # - name: Set KeyLocker Variables
    #   id: variables
    #   run: |
    #     echo "SM_HOST=${{ inputs.keylocker-host }}" >> "$GITHUB_ENV"
    #     echo "SM_API_KEY=${{ inputs.keylocker-api-key }}" >> "$GITHUB_ENV"
    #     echo "SM_CLIENT_CERT_PASSWORD=${{ inputs.certificate-password }}" >> "$GITHUB_ENV"
    #     echo "SM_CODE_SIGNING_CERT_SHA1_HASH=${{ inputs.keylocker-cert-sha1-hash }}" >> "$GITHUB_ENV"
    #     if [ "${{ runner.os }}" == "Windows" ]
    #     then
    #       echo "SM_CLIENT_CERT_FILE=D:\\cognite_code_signing_github_actions.p12" >> "$GITHUB_ENV"
    #     elif [ "${{ runner.os }}" == "Linux" ]
    #     then
    #       echo "SM_CLIENT_CERT_FILE=/d/cognite_code_signing_github_actions.p12" >> "$GITHUB_ENV"
    #       echo "PKCS11_CONFIG=/tmp/DigiCert One Signing Manager Tools/smtools-linux-x64/pkcs11properties.cfg" >> "$GITHUB_ENV"
    #       echo "/tmp/DigiCert One Signing Manager Tools/smtools-linux-x64" >> $GITHUB_PATH
    #     fi
    #   if: inputs.keylocker-host
    #   shell: bash
    # - name: Configure Digicert Secure Software Manager
    #   uses: digicert/ssm-code-signing@v0.0.2
    #   env:
    #     SM_API_KEY: ${{ env.SM_API_KEY }}
    #     SM_CLIENT_CERT_PASSWORD: ${{ env.SM_CLIENT_CERT_PASSWORD }}
    #     SM_CLIENT_CERT_FILE: ${{ env.SM_CLIENT_CERT_FILE }}
    #   if: inputs.keylocker-host
    # - name: Sign with smctl Windows
    #   env:
    #     GITHUB_WORKSPACE: ${{ github.workspace }}
    #   run: |
    #     smctl windows certsync --keypair-alias="${{ inputs.keylocker-keypair-alias }}"
    #     $file_path = "${{ env.GITHUB_WORKSPACE }}\${{ inputs.file }}"
    #     $files_to_sign = @()
    #     if (Test-Path -Path $file_path -PathType Leaf) {
    #       $files_to_sign = @([PSCustomObject]@{FullName = $file_path})
    #     }
    #     else {
    #       Get-ChildItem -Path $file_path -File -Recurse
    #       $files_to_sign = @(Get-ChildItem -Path $file_path -File -Recurse)
    #     }
    #     foreach ( $f in $files_to_sign )
    #     {
    #       smctl sign --fingerprint ${{ env.SM_CODE_SIGNING_CERT_SHA1_HASH }} --input $f.FullName
    #       smctl sign verify --input $f.FullName
    #     }
    #   if: runner.os == 'Windows' && inputs.keylocker-host
    #   shell: powershell
    # - name: Sign Linux with KeyLocker
    #   run: |
    #     curl -fSslL https://github.com/ebourg/jsign/releases/download/3.1/jsign_3.1_all.deb -o jsign_3.1_all.deb
    #     sudo dpkg --install jsign_3.1_all.deb
    #     file_path="${{ env.GITHUB_WORKSPACE }}/${{ inputs.file }}"
    #     for f in $(find $file_path -type f); do
    #       smctl sign -v --keypair-alias="${{ inputs.keylocker-keypair-alias }}" --config-file="/tmp/DigiCert One Signing Manager Tools/smtools-linux-x64/pkcs11properties.cfg" --fingerprint "${{ env.SM_CODE_SIGNING_CERT_SHA1_HASH }}" --input "$f"
    #       smctl sign verify --input $f
    #     done
    #   if: runner.os == 'Linux' && inputs.keylocker-host
    #   shell: bash
    # - name: Sign
    #   shell: powershell
    #   if: runner.os == 'Windows' && !inputs.keylocker-host
    #   env:
    #     FILE: ${{ inputs.file }}
    #     OPTIONS: ${{ inputs.options }}
    #     WINDOZE_CERT_DATA: ${{ inputs.certificate-data }}
    #     WINDOZE_CERT_PASSWORD: ${{ inputs.certificate-password }}
    #   run: |
    #     $ErrorActionPreference = "Stop"

    #     # Get some things for cert opts
    #     $file = -join($pwd, "/", $env:FILE);
    #     $temp_dir = $env:TMP
    #     $cert_data = $env:WINDOZE_CERT_DATA
    #     $cert_path = "$temp_dir\lando.windoze.p12"
    #     $cert_password = $env:WINDOZE_CERT_PASSWORD
    #     $cert_secure_password = $null
    #     $signtool = "${env:ProgramFiles(x86)}\Windows Kits\10\bin\x64\signtool.exe"
    #     $signtool2022 = "${env:ProgramFiles(x86)}\Windows Kits\10\bin\10.0.17763.0\x86\signtool.exe"

    #     # Throw error if file does not exist
    #     if (!(Test-Path "$file"))
    #     {
    #       throw "$file does not exist"
    #     }

    #     # Decode and dump to temp file
    #     If (!(Test-Path $cert_path)) {
    #       Write-Output "Dumping cert to $cert_path..."
    #       $bytes = [Convert]::FromBase64String($cert_data)
    #       [IO.File]::WriteAllBytes($cert_path, $bytes)
    #     }

    #     # Use more recent signtool if we can
    #     If (Test-Path $signtool2022) {
    #       $signtool = "$signtool2022"
    #     }

    #     # Verify the cert and password are good
    #     Write-Output "Verifying cert is good to go..."
    #     $cert_secure_password = ConvertTo-SecureString $cert_password -AsPlainText -Force
    #     Import-PfxCertificate -FilePath "$cert_path" -Password $cert_secure_password -CertStoreLocation "Cert:\LocalMachine\My"

    #     # If we get this far we should be good!
    #     Write-Output "We can sign!"

    #     # Sign and verify
    #     Write-Output "Trying to sign $file with $signtool..."
    #     & $signtool sign -f "$cert_path" -p "$cert_password" -fd sha256 -tr "http://timestamp.comodoca.com/?td=sha256" -td sha256 $env:OPTIONS -as -v "$file"
    #     Write-Output "Verifying $file has been signed with the signtool..."
    #     & $signtool verify -pa -v "$file"

    - name: Notarizing
      if: steps.code-sign-action-internal.outputs.notarize == 'true'
      uses: lando/notarize-action@v2
      with:
        appstore-connect-username: ${{ inputs.apple-notary-user }}
        appstore-connect-password: ${{ inputs.apple-notary-password }}
        appstore-connect-team-id: ${{ steps.code-sign-action-internal.outputs.certid }}
        primary-bundle-id: ${{ inputs.apple-product-id }}
        product-path: ${{ steps.code-sign-action-internal.outputs.file }}
        tool: ${{ inputs.apple-notary-tool }}
        verbose: true
    - name: Verifying Notarization
      if: steps.code-sign-action-internal.outputs.notarize == 'true'
      run: codesign -vvvv -R="notarized" --check-notarization "${{ steps.code-sign-action-internal.outputs.file }}"
    - name: Set outputs
      shell: bash
      id: code-sign-action
      run: |
        echo "::group::Setting outputs"
        echo "file=${{ steps.code-sign-action-internal.outputs.file }}" >> $GITHUB_OUTPUT
        echo "::endgroup::"
